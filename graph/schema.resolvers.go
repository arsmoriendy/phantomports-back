package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.50

import (
	"context"
	"errors"
	"fmt"

	"github.com/arsmoriendy/opor/gql-srv/graph/model"
	"github.com/arsmoriendy/opor/gql-srv/internal"
)

var ErrPortsOutOfBounds = errors.New("indexing out of bounds for ports registry")

// Ports is the resolver for the ports field.
func (r *queryResolver) Ports(ctx context.Context, portNumber *int, after *int) ([]*model.Port, error) {
	rports := r.ports
	if portNumber != nil {
		rports = internal.Filter(rports, func(p *model.Port) bool {
			for _, portnum := range p.PortNumber {
				if portnum == *portNumber {
					return true
				}
			}
			return false
		})
		return rports, nil
	}

	after_int := 0
	if after != nil {
		after_int = *after
	}

	n := len(rports)
	first := 100 // max ports to search
	from := after_int + 1
	to := from + first

	if from > n-1 {
		return nil, fmt.Errorf(
			"%w: tried to index(zero based) %v out of %v ports",
			ErrPortsOutOfBounds, from, n,
		)
	}

	if to > n {
		return rports[from:], nil
	}

	return rports[from:to], nil
}

// LastChecked is the resolver for the lastChecked field.
func (r *queryResolver) LastChecked(ctx context.Context) (int, error) {
	return int(r.lastChecked.Unix()), nil
}

// NextOpenPort is the resolver for the nextOpenPort field.
func (r *queryResolver) NextOpenPort(ctx context.Context, portNumber int) (*int, error) {
	tofind := model.Port{
		PortNumber: []int{portNumber},
	}

	found, idx, _ := r.SearchPort(&tofind)
	if !found {
		return &portNumber, nil
	}

	nextPortIdx := idx + 1
	for i := nextPortIdx; i < uint(len(r.ports)); i++ {
		p := r.ports[i]
		if p.Empty() {
			continue
		}

		if p.Description != nil && *(p.Description) == "Unassigned" {
			firstport := p.PortNumber[0]
			return &firstport, nil
		}
	}

	return nil, nil
}

// PrevOpenPort is the resolver for the prevOpenPort field.
func (r *queryResolver) PrevOpenPort(ctx context.Context, portNumber int) (*int, error) {
	tofind := model.Port{
		PortNumber: []int{portNumber},
	}

	found, idx, _ := r.SearchPort(&tofind)
	if !found {
		return &portNumber, nil
	}

	prevPortIdx := idx - 1
	for i := prevPortIdx; i > 0; i-- {
		p := r.ports[i]
		if p.Empty() {
			continue
		}

		if p.Description != nil && *(p.Description) == "Unassigned" {
			lastport := p.PortNumber[len(p.PortNumber)-1]
			return &lastport, nil
		}
	}

	return nil, nil
}

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

type queryResolver struct{ *Resolver }
